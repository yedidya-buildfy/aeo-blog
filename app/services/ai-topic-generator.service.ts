import type { PrismaClient } from '@prisma/client';
import type { KeywordContext } from './keyword-aggregation.service';
import * as crypto from 'crypto';

export type ContentAngle = 'how-to' | 'benefits' | 'problems' | 'comparison' | 'trend';

export interface GeneratedTopic {
  title: string;
  handle: string;
  primaryTopic: string;
  keywordsFocused: string[];
  description: string;
  angle: string;
  contentHash: string;
  isUnique: boolean;
}

export interface BlogPrompt {
  primaryTopic: string;
  keywordsFocused: string[];
  contentAngle: ContentAngle;
  title: string;
  handle: string;
  contentHash: string;
  isUnique: boolean;
}

export interface TopicBatch {
  topics: GeneratedTopic[];
  usedTopics: string[];
  batchNumber: number;
  shopDomain: string;
  createdAt: Date;
}

export class AITopicGeneratorService {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent';

  constructor(private prisma: PrismaClient) {
    console.log(`[AITopicGenerator] Constructor called with prisma:`, !!prisma);
    this.apiKey = process.env.GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('GEMINI_API_KEY environment variable is required');
    }
    console.log(`[AITopicGenerator] Constructor completed, apiKey present:`, !!this.apiKey);
  }

  /**
   * Get the next available blog prompt for a shop (compatible with existing workflow)
   */
  async generateUniqueBlogPrompt(shopDomain: string, keywordContext: KeywordContext, storeUrl?: string): Promise<BlogPrompt> {
    console.log(`[AITopicGenerator] generateUniqueBlogPrompt called for ${shopDomain}, prisma:`, !!this.prisma);
    const topic = await this.getNextTopic(shopDomain, keywordContext, storeUrl);

    return {
      primaryTopic: topic.primaryTopic,
      keywordsFocused: topic.keywordsFocused,
      contentAngle: topic.angle as ContentAngle,
      title: topic.title,
      handle: topic.handle,
      contentHash: topic.contentHash,
      isUnique: topic.isUnique
    };
  }

  /**
   * Get the next available topic for a shop
   */
  async getNextTopic(shopDomain: string, keywordContext: KeywordContext, storeUrl?: string): Promise<GeneratedTopic> {
    // Check if we have unused topics in current batch
    const currentBatch = await this.getCurrentBatch(shopDomain);

    if (currentBatch && currentBatch.topics.length > 0) {
      const nextTopic = currentBatch.topics[0];

      // Remove this topic from the batch and mark as used
      await this.markTopicAsUsed(shopDomain, nextTopic);

      console.log(`[AITopicGenerator] Using topic from batch: ${nextTopic.title}`);
      return nextTopic;
    }

    // No topics available, generate a new batch
    console.log('[AITopicGenerator] Generating new batch of topics');
    const newBatch = await this.generateTopicBatch(shopDomain, keywordContext, storeUrl);

    if (newBatch.topics.length === 0) {
      throw new Error('Failed to generate any topics');
    }

    // Return the first topic and mark it as used
    const firstTopic = newBatch.topics[0];
    await this.markTopicAsUsed(shopDomain, firstTopic);

    return firstTopic;
  }

  /**
   * Generate a new batch of 10 unique topics using AI
   */
  async generateTopicBatch(shopDomain: string, keywordContext: KeywordContext, storeUrl?: string): Promise<TopicBatch> {
    // Get previously used topics to avoid duplication
    const usedTopics = await this.getUsedTopics(shopDomain);

    const prompt = this.buildTopicGenerationPrompt(keywordContext, usedTopics, storeUrl);

    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: prompt
            }
          ]
        }
      ],
      generationConfig: {
        temperature: 0.8,
        topP: 0.9,
        topK: 40,
        maxOutputTokens: 15000, // Sufficient for 10 topics without being excessive
        stopSequences: []
      }
    };

    try {
      console.log(`[AITopicGenerator] Generating topics for shop: ${shopDomain}`);
      console.log(`[AITopicGenerator] Request config: maxOutputTokens=${requestBody.generationConfig.maxOutputTokens}`);
      console.log(`[AITopicGenerator] Prompt length: ${requestBody.contents[0].parts[0].text.length} characters`);

      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': this.apiKey
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();

      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No content generated by Gemini API');
      }

      const candidate = data.candidates[0];

      // Check for MAX_TOKENS finish reason
      if (candidate.finishReason === 'MAX_TOKENS') {
        console.warn('[AITopicGenerator] Response was truncated due to MAX_TOKENS');
        throw new Error('Topic generation was truncated. Please try again.');
      }

      if (!candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        console.error('[AITopicGenerator] Invalid response structure:', JSON.stringify(candidate, null, 2));
        throw new Error('Invalid response structure from Gemini API');
      }

      const generatedText = candidate.content.parts[0].text;
      const topics = this.parseGeneratedTopics(generatedText, keywordContext);

      // Save the batch to database
      const batch = await this.saveBatch(shopDomain, topics, usedTopics);

      console.log(`[AITopicGenerator] Generated ${topics.length} topics successfully`);
      return batch;

    } catch (error) {
      console.error('Error generating topics with Gemini API:', error);
      throw error;
    }
  }

  private buildTopicGenerationPrompt(keywordContext: KeywordContext, usedTopics: string[], storeUrl?: string): string {
    const allKeywords = [
      ...keywordContext.mainProducts,
      ...keywordContext.problemsSolved,
      ...keywordContext.customerSearches
    ].join(', ');

    const usedTopicsText = usedTopics.length > 0
      ? `\n\nTry to avoid reusing these topics because we already used them:\n${usedTopics.join(', ')}`
      : '';

    const websiteContext = storeUrl
      ? `\n\nWebsite URL for context: ${storeUrl}\nConsider the website's industry, audience, and business type when generating topics.`
      : '';

    return `Based on these keywords from a website: ${allKeywords}${websiteContext}

Generate 10 diverse, engaging blog post topics that would be relevant to the website's audience. The topics should cover different angles and interests, not just business-focused content.

Consider various content types:
- How-to guides and tutorials
- Industry insights and trends
- Problem-solving articles
- Comparison and review posts
- Educational content
- Tips and best practices
- Case studies and examples
- Innovation and future perspectives

For each topic, provide:
1. An engaging title (different from just a description)
2. A brief description of what the post would cover
3. The main angle/approach (how-to, benefits, trends, etc.)
4. 3-5 relevant keywords to focus on

Format your response exactly as:

TOPIC 1:
TITLE: [Engaging blog title]
DESCRIPTION: [Brief description of content]
ANGLE: [Content approach/angle]
KEYWORDS: [keyword1, keyword2, keyword3]

TOPIC 2:
TITLE: [Engaging blog title]
DESCRIPTION: [Brief description of content]
ANGLE: [Content approach/angle]
KEYWORDS: [keyword1, keyword2, keyword3]

[Continue for all 10 topics]${usedTopicsText}`;
  }

  private parseGeneratedTopics(generatedText: string, keywordContext: KeywordContext): GeneratedTopic[] {
    const topics: GeneratedTopic[] = [];
    const topicBlocks = generatedText.split(/TOPIC \d+:/);

    for (let i = 1; i < topicBlocks.length; i++) {
      const block = topicBlocks[i].trim();

      try {
        const titleMatch = block.match(/TITLE:\s*(.+)/);
        const descriptionMatch = block.match(/DESCRIPTION:\s*(.+)/);
        const angleMatch = block.match(/ANGLE:\s*(.+)/);
        const keywordsMatch = block.match(/KEYWORDS:\s*(.+)/);

        if (titleMatch && descriptionMatch && angleMatch && keywordsMatch) {
          const title = titleMatch[1].trim();
          const description = descriptionMatch[1].trim();
          const angle = angleMatch[1].trim();
          const keywords = keywordsMatch[1].split(',').map(k => k.trim());

          const topic: GeneratedTopic = {
            title,
            handle: this.generateHandle(title),
            primaryTopic: title,
            keywordsFocused: keywords,
            description,
            angle,
            contentHash: this.generateContentHash(title, keywords, angle),
            isUnique: true
          };

          topics.push(topic);
        }
      } catch (error) {
        console.warn(`[AITopicGenerator] Failed to parse topic block ${i}:`, error);
      }
    }

    return topics;
  }

  private generateHandle(title: string): string {
    return title
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .replace(/-+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 50) + '-' + Date.now().toString().slice(-6);
  }

  private async getCurrentBatch(shopDomain: string): Promise<{ topics: GeneratedTopic[] } | null> {
    console.log(`[AITopicGenerator] getCurrentBatch called, this.prisma:`, !!this.prisma);
    const batch = await this.prisma.topicBatch.findFirst({
      where: {
        shopDomain,
        topics: {
          not: {
            equals: '[]'
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    if (!batch) return null;

    return {
      topics: JSON.parse(batch.topics as string) as GeneratedTopic[]
    };
  }

  private async saveBatch(
    shopDomain: string,
    topics: GeneratedTopic[],
    usedTopics: string[]
  ): Promise<TopicBatch> {
    const batchNumber = await this.getNextBatchNumber(shopDomain);

    const saved = await this.prisma.topicBatch.create({
      data: {
        shopDomain,
        batchNumber,
        topics: JSON.stringify(topics),
        usedTopics: JSON.stringify(usedTopics),
        createdAt: new Date()
      }
    });

    return {
      topics,
      usedTopics,
      batchNumber,
      shopDomain,
      createdAt: saved.createdAt
    };
  }

  private async markTopicAsUsed(shopDomain: string, topic: GeneratedTopic): Promise<void> {
    // Get current batch
    const batch = await this.prisma.topicBatch.findFirst({
      where: {
        shopDomain,
        topics: {
          not: {
            equals: '[]'
          }
        }
      },
      orderBy: { createdAt: 'desc' }
    });

    if (!batch) return;

    const currentTopics = JSON.parse(batch.topics as string) as GeneratedTopic[];
    const remainingTopics = currentTopics.filter(t => t.title !== topic.title);

    // Update the batch with remaining topics
    await this.prisma.topicBatch.update({
      where: { id: batch.id },
      data: {
        topics: JSON.stringify(remainingTopics)
      }
    });

    // Add topic to blog posts table when it's actually used
    // This will be done by the calling service
  }

  private async getUsedTopics(shopDomain: string): Promise<string[]> {
    const blogs = await this.prisma.blogPost.findMany({
      where: { shopDomain },
      select: { primaryTopic: true },
      orderBy: { createdAt: 'desc' },
      take: 50 // Last 50 topics to avoid very long prompts
    });

    return blogs.map(blog => blog.primaryTopic);
  }

  private async getNextBatchNumber(shopDomain: string): Promise<number> {
    const lastBatch = await this.prisma.topicBatch.findFirst({
      where: { shopDomain },
      orderBy: { batchNumber: 'desc' }
    });

    return (lastBatch?.batchNumber || 0) + 1;
  }

  private generateContentHash(primaryTopic: string, keywordsFocused: string[], angle: string): string {
    const content = `${primaryTopic}-${keywordsFocused.sort().join(',')}-${angle}`;
    return crypto.createHash('sha256').update(content).digest('hex').substring(0, 16);
  }
}