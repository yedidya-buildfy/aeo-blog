import type { KeywordContext } from './keyword-aggregation.service';
import type { BlogPrompt } from './ai-topic-generator.service';
import { franc } from 'franc';

export interface GeneratedBlog {
  title: string;
  content: string;
  summary: string;
  handle: string;
  metaDescription: string;
  tags: string[];
  wordCount: number;
}

export interface BlogGenerationRequest {
  prompt: BlogPrompt;
  keywordContext: KeywordContext;
  storeUrl: string;
  brandName?: string;
}

export class BlogGeneratorService {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('GEMINI_API_KEY environment variable is required');
    }
  }

  async generateBlog(request: BlogGenerationRequest): Promise<GeneratedBlog> {
    const maxRetries = 3;
    let lastError: Error;

    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      try {
        console.log(`[BlogGenerator] Generating blog (attempt ${attempt}/${maxRetries}): ${request.prompt.title}`);

        const blogPrompt = this.buildBlogPrompt(request, attempt);
        const requestBody = {
          contents: [
            {
              parts: [
                {
                  text: blogPrompt
                }
              ]
            }
          ],
          generationConfig: {
            temperature: 0.7,
            topP: 0.9,
            topK: 40,
            maxOutputTokens: 10000,
            stopSequences: []
          }
        };

        const response = await fetch(this.baseUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'x-goog-api-key': this.apiKey
          },
          body: JSON.stringify(requestBody)
        });

        if (!response.ok) {
          throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
        }

        const data = await response.json();

        if (!data.candidates || data.candidates.length === 0) {
          throw new Error('No content generated by Gemini API');
        }

        const candidate = data.candidates[0];

        // Check for MAX_TOKENS - retry with smaller word count
        if (candidate.finishReason === 'MAX_TOKENS') {
          console.warn(`[BlogGenerator] Response truncated due to MAX_TOKENS on attempt ${attempt}`);
          if (attempt < maxRetries) {
            console.log(`[BlogGenerator] Retrying with reduced word count target`);
            continue; // Retry with smaller target
          } else {
            console.warn(`[BlogGenerator] Using partial content from final attempt`);
            // Continue processing - we'll validate content quality below
          }
        }

        if (!candidate || !candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
          console.error('[BlogGenerator] Invalid response structure:', JSON.stringify(candidate, null, 2));
          throw new Error('Invalid response structure from Gemini API');
        }

        const generatedText = candidate.content.parts[0].text;
        const parsedBlog = this.parseBlogContent(generatedText, request);

        if (!parsedBlog.title || !parsedBlog.content || parsedBlog.wordCount < 100) {
          throw new Error('Generated content is incomplete or too short');
        }

        console.log(`[BlogGenerator] Successfully generated ${parsedBlog.wordCount} words`);
        return parsedBlog;

      } catch (error) {
        lastError = error as Error;
        console.error(`[BlogGenerator] Attempt ${attempt} failed:`, error);

        if (attempt === maxRetries) {
          break;
        }

        // Wait before retry (shorter delay for faster response)
        const delay = 1000; // Fixed 1 second delay instead of exponential
        console.log(`[BlogGenerator] Retrying in ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
      }
    }

    // All retries failed
    throw new Error(`Failed to generate blog content after ${maxRetries} attempts. ${lastError.message}`);
  }

  private buildBlogPrompt(request: BlogGenerationRequest, attempt: number = 1): string {
    const { prompt, keywordContext, storeUrl, brandName } = request;

    // Use the same language as the keywords
    const allKeywords = [
      ...keywordContext.mainProducts,
      ...keywordContext.problemsSolved,
      ...keywordContext.customerSearches
    ];

    // Detect language from keywords using franc
    const detectedLanguage = this.detectLanguage(allKeywords);

    // Randomly select 5-8 keywords
    const numKeywords = Math.floor(Math.random() * 4) + 5; // 5-8 keywords
    const shuffledKeywords = allKeywords.sort(() => Math.random() - 0.5);
    const sampleKeywords = shuffledKeywords.slice(0, Math.min(numKeywords, allKeywords.length)).join(', ');

    // Progressive word count reduction based on attempt
    const wordCounts = {
      1: '800-1000 words',
      2: '600-800 words',
      3: '400-500 words'
    };
    const targetWordCount = wordCounts[attempt as keyof typeof wordCounts] || '400-500 words';

    // Adjust complexity based on attempt
    const complexity = attempt === 1
      ? 'comprehensive content with clear structure using H2 and H3 headings, include actionable tips, examples, and detailed explanations'
      : attempt === 2
      ? 'clear structure with H2 headings, include actionable tips and examples'
      : 'clear structure with H2 headings, include actionable tips';

    return `Write an SEO blog post in ${detectedLanguage} about: ${prompt.title}

Keywords: ${sampleKeywords}

Requirements: ${targetWordCount}, ${complexity}.

Format:
TITLE: [engaging title]
SUMMARY: [2 sentences with keywords]
META_DESCRIPTION: [160 chars max]
TAGS: [6 tags]
CONTENT: [HTML blog content, ${targetWordCount} with multiple sections]`;
  }


  private parseBlogContent(generatedText: string, request: BlogGenerationRequest): GeneratedBlog {
    const sections = this.extractSections(generatedText);

    // Use fallbacks if sections are missing - be flexible
    const cleanTitle = sections.TITLE ? this.cleanText(sections.TITLE) : request.prompt.title;
    const cleanSummary = sections.SUMMARY ? this.cleanText(sections.SUMMARY) : 'Auto-generated blog content';
    const cleanMeta = sections.META_DESCRIPTION ? this.cleanText(sections.META_DESCRIPTION).substring(0, 160) : cleanTitle.substring(0, 160);
    const tags = sections.TAGS ? sections.TAGS.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0) : ['blog', 'seo'];
    const cleanContent = sections.CONTENT ? this.cleanHtmlContent(sections.CONTENT) : this.cleanHtmlContent(generatedText);

    // More lenient validation - just check we have some content
    if (cleanContent.length < 50) {
      throw new Error('Generated content is too short');
    }

    return {
      title: cleanTitle,
      content: cleanContent,
      summary: cleanSummary,
      handle: request.prompt.handle,
      metaDescription: cleanMeta,
      tags: tags.slice(0, 8), // Limit to 8 tags
      wordCount: this.countWords(cleanContent)
    };
  }

  private extractSections(text: string): Record<string, string> {
    const sections: Record<string, string> = {};
    const sectionNames = ['TITLE', 'SUMMARY', 'META_DESCRIPTION', 'TAGS', 'CONTENT'];

    for (let i = 0; i < sectionNames.length; i++) {
      const currentSection = sectionNames[i];
      const nextSection = sectionNames[i + 1];

      const startPattern = new RegExp(`${currentSection}:\\s*`, 'i');
      const startMatch = text.search(startPattern);

      if (startMatch === -1) continue;

      const contentStart = text.search(startPattern) + text.match(startPattern)?.[0].length || 0;

      let contentEnd = text.length;
      if (nextSection) {
        const endPattern = new RegExp(`${nextSection}:\\s*`, 'i');
        const endMatch = text.search(endPattern);
        if (endMatch > contentStart) {
          contentEnd = endMatch;
        }
      }

      sections[currentSection] = text.substring(contentStart, contentEnd).trim();
    }

    return sections;
  }

  private cleanText(text: string): string {
    return text
      .replace(/^\[|\]$/g, '') // Remove brackets
      .replace(/\*\*/g, '') // Remove markdown bold
      .replace(/\*/g, '') // Remove markdown italic
      .trim();
  }

  private cleanHtmlContent(content: string): string {
    return content
      .replace(/```html|```/g, '') // Remove code blocks
      .replace(/^\[|\]$/g, '') // Remove brackets
      .trim();
  }

  private countWords(content: string): number {
    return content
      .replace(/<[^>]*>/g, ' ') // Remove HTML tags
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }


  private detectLanguage(keywords: string[]): string {
    const text = keywords.join(' ');

    if (text.trim().length === 0) {
      return 'English';
    }

    // Use franc to detect language
    const languageCode = franc(text);

    // Map common language codes to full language names
    const languageMap: Record<string, string> = {
      'eng': 'English',
      'heb': 'Hebrew',
      'ara': 'Arabic',
      'spa': 'Spanish',
      'fra': 'French',
      'deu': 'German',
      'ita': 'Italian',
      'por': 'Portuguese',
      'rus': 'Russian',
      'jpn': 'Japanese',
      'kor': 'Korean',
      'cmn': 'Chinese',
      'und': 'English' // undetermined -> default to English
    };

    return languageMap[languageCode] || 'English';
  }
}