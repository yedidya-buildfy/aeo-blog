import type { KeywordContext } from './keyword-aggregation.service';
import type { BlogPrompt } from './ai-topic-generator.service';
import { franc } from 'franc';

export interface GeneratedBlog {
  title: string;
  content: string;
  summary: string;
  handle: string;
  metaDescription: string;
  tags: string[];
  wordCount: number;
}

export interface BlogGenerationRequest {
  prompt: BlogPrompt;
  keywordContext: KeywordContext;
  storeUrl: string;
  brandName?: string;
}

export class BlogGeneratorService {
  private apiKey: string;
  private baseUrl = 'https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash:generateContent';

  constructor() {
    this.apiKey = process.env.GEMINI_API_KEY || '';
    if (!this.apiKey) {
      throw new Error('GEMINI_API_KEY environment variable is required');
    }
  }

  async generateBlog(request: BlogGenerationRequest): Promise<GeneratedBlog> {
    const blogPrompt = this.buildBlogPrompt(request);

    const requestBody = {
      contents: [
        {
          parts: [
            {
              text: blogPrompt
            }
          ]
        }
      ],
      generationConfig: {
        temperature: 0.7,
        topP: 0.9,
        topK: 40,
        maxOutputTokens: 2000,
        stopSequences: []
      }
    };

    try {
      console.log(`[BlogGenerator] Generating blog: ${request.prompt.title}`);

      const response = await fetch(this.baseUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'x-goog-api-key': this.apiKey
        },
        body: JSON.stringify(requestBody)
      });

      if (!response.ok) {
        throw new Error(`Gemini API error: ${response.status} ${response.statusText}`);
      }

      const data = await response.json();

      console.log('[BlogGenerator] API Response:', JSON.stringify(data, null, 2));

      if (!data.candidates || data.candidates.length === 0) {
        throw new Error('No content generated by Gemini API');
      }

      const candidate = data.candidates[0];

      // Handle MAX_TOKENS with fallback content
      if (candidate.finishReason === 'MAX_TOKENS') {
        console.warn('[BlogGenerator] Response was truncated due to MAX_TOKENS, using available content');
        // Continue processing - we'll handle truncated content in parseBlogContent
      }

      if (!candidate || !candidate.content || !candidate.content.parts || candidate.content.parts.length === 0) {
        console.error('[BlogGenerator] Invalid response structure:', JSON.stringify(candidate, null, 2));
        throw new Error('Invalid response structure from Gemini API');
      }

      const generatedText = candidate.content.parts[0].text;
      const parsedBlog = this.parseBlogContent(generatedText, request);

      console.log(`[BlogGenerator] Successfully generated ${parsedBlog.wordCount} words`);
      return parsedBlog;

    } catch (error) {
      console.error('Error calling Gemini API for blog generation:', error);
      throw error;
    }
  }

  private buildBlogPrompt(request: BlogGenerationRequest): string {
    const { prompt, keywordContext, storeUrl, brandName } = request;

    // Use the same language as the keywords
    const allKeywords = [
      ...keywordContext.mainProducts,
      ...keywordContext.problemsSolved,
      ...keywordContext.customerSearches
    ];

    // Detect language from keywords using franc
    const detectedLanguage = this.detectLanguage(allKeywords);

    // Randomly select 5-8 keywords
    const numKeywords = Math.floor(Math.random() * 4) + 5; // 5-8 keywords
    const shuffledKeywords = allKeywords.sort(() => Math.random() - 0.5);
    const sampleKeywords = shuffledKeywords.slice(0, Math.min(numKeywords, allKeywords.length)).join(', ');

    return `Write an SEO blog post in ${detectedLanguage} about: ${prompt.title}

Keywords: ${sampleKeywords}

Requirements: 400-500 words, clear structure with H2 headings, include actionable tips.

Format:
TITLE: [engaging title]
SUMMARY: [2 sentences with keywords]
META_DESCRIPTION: [160 chars max]
TAGS: [6 tags]
CONTENT: [HTML blog content, 400-500 words]`;
  }


  private parseBlogContent(generatedText: string, request: BlogGenerationRequest): GeneratedBlog {
    const sections = this.extractSections(generatedText);

    // Extract each section
    const title = sections.TITLE || request.prompt.title;
    const summary = sections.SUMMARY || this.generateFallbackSummary(title);
    const metaDescription = sections.META_DESCRIPTION || this.generateFallbackMeta(title);
    const tagsStr = sections.TAGS || this.generateFallbackTags(request.keywordContext);
    const content = sections.CONTENT || this.generateFallbackContent(title, request.keywordContext);

    // Clean and process
    const cleanTitle = this.cleanText(title);
    const cleanSummary = this.cleanText(summary);
    const cleanMeta = this.cleanText(metaDescription).substring(0, 160);
    const tags = tagsStr.split(',').map(tag => tag.trim()).filter(tag => tag.length > 0);
    const cleanContent = this.cleanHtmlContent(content);

    return {
      title: cleanTitle,
      content: cleanContent,
      summary: cleanSummary,
      handle: request.prompt.handle,
      metaDescription: cleanMeta,
      tags: tags.slice(0, 8), // Limit to 8 tags
      wordCount: this.countWords(cleanContent)
    };
  }

  private extractSections(text: string): Record<string, string> {
    const sections: Record<string, string> = {};
    const sectionNames = ['TITLE', 'SUMMARY', 'META_DESCRIPTION', 'TAGS', 'CONTENT'];

    for (let i = 0; i < sectionNames.length; i++) {
      const currentSection = sectionNames[i];
      const nextSection = sectionNames[i + 1];

      const startPattern = new RegExp(`${currentSection}:\\s*`, 'i');
      const startMatch = text.search(startPattern);

      if (startMatch === -1) continue;

      const contentStart = text.search(startPattern) + text.match(startPattern)?.[0].length || 0;

      let contentEnd = text.length;
      if (nextSection) {
        const endPattern = new RegExp(`${nextSection}:\\s*`, 'i');
        const endMatch = text.search(endPattern);
        if (endMatch > contentStart) {
          contentEnd = endMatch;
        }
      }

      sections[currentSection] = text.substring(contentStart, contentEnd).trim();
    }

    return sections;
  }

  private cleanText(text: string): string {
    return text
      .replace(/^\[|\]$/g, '') // Remove brackets
      .replace(/\*\*/g, '') // Remove markdown bold
      .replace(/\*/g, '') // Remove markdown italic
      .trim();
  }

  private cleanHtmlContent(content: string): string {
    return content
      .replace(/```html|```/g, '') // Remove code blocks
      .replace(/^\[|\]$/g, '') // Remove brackets
      .trim();
  }

  private countWords(content: string): number {
    return content
      .replace(/<[^>]*>/g, ' ') // Remove HTML tags
      .split(/\s+/)
      .filter(word => word.length > 0).length;
  }

  private generateFallbackSummary(title: string): string {
    return `Discover valuable insights about ${title.toLowerCase()}. Learn practical tips and strategies to improve your business success.`;
  }

  private generateFallbackMeta(title: string): string {
    return `${title} - Essential guide with tips, strategies and best practices for business success.`.substring(0, 160);
  }

  private generateFallbackTags(keywordContext: KeywordContext): string {
    const tags = [
      ...keywordContext.mainProducts.slice(0, 3),
      ...keywordContext.problemsSolved.slice(0, 2),
      'business', 'guide', 'tips'
    ];
    return tags.join(', ');
  }

  private generateFallbackContent(title: string, keywordContext: KeywordContext): string {
    const mainKeyword = keywordContext.mainProducts[0] || keywordContext.problemsSolved[0] || 'this topic';
    const problemKeyword = keywordContext.problemsSolved[0] || 'common challenges';
    const customerKeyword = keywordContext.customerSearches[0] || 'your needs';

    return `<h2>Introduction</h2>
<p>Welcome to this comprehensive guide about ${title.toLowerCase()}. Understanding ${mainKeyword} can help you achieve your goals and improve your experience.</p>

<h2>Key Points</h2>
<ul>
<li>Learn essential information about ${mainKeyword}</li>
<li>Discover practical solutions and tips</li>
<li>Get actionable advice you can implement today</li>
</ul>

<h2>Getting Started</h2>
<p>To begin, focus on understanding ${problemKeyword} and how to address ${customerKeyword} effectively.</p>

<h2>Next Steps</h2>
<p>Ready to learn more? Continue reading to discover valuable insights and practical tips that can make a real difference.</p>`;
  }

  private detectLanguage(keywords: string[]): string {
    const text = keywords.join(' ');

    if (text.trim().length === 0) {
      return 'English';
    }

    // Use franc to detect language
    const languageCode = franc(text);

    // Map common language codes to full language names
    const languageMap: Record<string, string> = {
      'eng': 'English',
      'heb': 'Hebrew',
      'ara': 'Arabic',
      'spa': 'Spanish',
      'fra': 'French',
      'deu': 'German',
      'ita': 'Italian',
      'por': 'Portuguese',
      'rus': 'Russian',
      'jpn': 'Japanese',
      'kor': 'Korean',
      'cmn': 'Chinese',
      'und': 'English' // undetermined -> default to English
    };

    return languageMap[languageCode] || 'English';
  }
}